name: CI/CD Pipeline - Microservices

on:
  push:
    branches:
      - master
      - develop
    paths:
      - '*-service/**'
      - 'api-gateway/**'
      - 'pom.xml'
  pull_request:
    branches:
      - master
      - develop
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - stage
          - prod
      deploy:
        description: 'Deploy to AKS?'
        required: true
        default: 'true'
        type: boolean

env:
  JAVA_VERSION: '17'
  MAVEN_OPTS: '-Xmx1024m'
  ACR_NAME: 'ecommercerojas435acr'
  AKS_CLUSTER: 'dev-aks-cluster'
  AKS_RESOURCE_GROUP: 'ecommerce-dev-rg'
  NAMESPACE: 'ecommerce-minimal'

jobs:
  # Stage 1: Build and Test
  build-and-test:
    name: Build, Test & Code Analysis
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for SonarCloud
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'
      
      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-
      
      - name: Build with Maven
        run: mvn clean compile -B -DskipTests
      
      - name: Run Unit Tests with JaCoCo
        run: mvn test jacoco:report -B -Dmaven.test.failure.ignore=true
        continue-on-error: true
      
      - name: Generate JaCoCo Report
        run: mvn jacoco:report-aggregate -B
        continue-on-error: true
      
      - name: Publish Test Results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Maven Tests
          path: '**/target/surefire-reports/TEST-*.xml'
          reporter: java-junit
          fail-on-error: false
      
      - name: SonarCloud Scan
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          mvn sonar:sonar \
            -Dsonar.projectKey=rojas435_ecommerce-microservices \
            -Dsonar.organization=rojas435 \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.coverage.jacoco.xmlReportPaths=**/target/site/jacoco/jacoco.xml \
            -Dsonar.java.coveragePlugin=jacoco
      
      - name: Upload JaCoCo Coverage Reports
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-reports
          path: |
            **/target/site/jacoco/
            **/target/jacoco.exec
          retention-days: 30
      
      - name: Package applications
        run: mvn package -DskipTests -B
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: maven-artifacts
          path: |
            **/target/*.jar
            !**/target/*-original.jar
          retention-days: 7

  # Stage 1.5: Semantic Versioning & Release (non-intrusive)
  semantic-version:
    name: Semantic Versioning & Release Tag
    runs-on: ubuntu-latest
    needs: build-and-test
    outputs:
      version: ${{ steps.setversion.outputs.semver }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v0.9
        with:
          versionSpec: '5.x'

      - name: Determine Semantic Version
        id: gitversion
        uses: gittools/actions/gitversion/execute@v0.9
        with:
          useConfigFile: true
          configFilePath: .github/gitversion.yml
        continue-on-error: true

      - name: Set Version Output (with robust fallback)
        id: setversion
        run: |
          GIT_SEMVER='${{ steps.gitversion.outputs.semver }}'
          if [ -z "$GIT_SEMVER" ]; then
            DATE_PART=$(date +%Y.%m.%d)
            FALLBACK="${DATE_PART}.${{ github.run_number }}"
            echo "GitVersion empty; using fallback $FALLBACK"
            echo "semver=$FALLBACK" >> $GITHUB_OUTPUT
          else
            echo "semver=$GIT_SEMVER" >> $GITHUB_OUTPUT
          fi

      - name: Create Tag & Release (master push only)
        if: github.ref == 'refs/heads/master' && github.event_name == 'push'
        env:
          SEMVER: ${{ steps.setversion.outputs.semver }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if git tag -l | grep -q "v$SEMVER"; then
            echo "Tag v$SEMVER already exists, skipping"
          else
            git config user.name "github-actions"
            git config user.email "github-actions@github.com"
            git tag v$SEMVER
            git push origin v$SEMVER
          fi
          echo "Creating GitHub Release for v$SEMVER"
          gh release create v$SEMVER --generate-notes || echo "Release already exists"

  # Stage 2: Security Scanning
  security-scan:
    name: Security & Vulnerability Scan
    runs-on: ubuntu-latest
    needs: [build-and-test, semantic-version]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: maven-artifacts
      
      - name: Run Trivy vulnerability scanner (filesystem)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-fs-results.sarif'
      
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-fs-results.sarif'
      
      - name: Run OWASP Dependency Check
        run: |
          mvn org.owasp:dependency-check-maven:check \
            -DfailBuildOnCVSS=7 \
            -DsuppressionFile=dependency-check-suppressions.xml || true
      
      - name: Upload OWASP Report
        uses: actions/upload-artifact@v4
        with:
          name: owasp-report
          path: '**/target/dependency-check-report.html'
          retention-days: 30

  # Stage 3: Build and Push Docker Images
  build-docker-images:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [build-and-test, semantic-version, security-scan]
    if: github.event_name == 'push' || github.event.inputs.deploy == 'true'
    
    strategy:
      matrix:
        service:
          - order-service
          - payment-service
          - shipping-service
          - product-service
          - user-service
          - api-gateway
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: maven-artifacts
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Azure Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}
      
      - name: Extract version from pom.xml
        id: version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "short_sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
      
      - name: Build Docker image
        run: |
          SEMVER='${{ needs.semantic-version.outputs.version }}'
          if [ -n "$SEMVER" ]; then echo "Semantic Version detected: $SEMVER"; fi
          cat > Dockerfile.${{ matrix.service }} <<EOF
          FROM eclipse-temurin:17-jre-alpine
          WORKDIR /app
          COPY ${{ matrix.service }}/target/*.jar app.jar
          EXPOSE 8080
          ENV JAVA_OPTS="-Xmx256m -Xms128m"
          ENTRYPOINT ["sh", "-c", "java \$JAVA_OPTS -jar app.jar"]
          EOF
          
          docker build \
            -t ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:${{ steps.version.outputs.version }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:${{ steps.version.outputs.short_sha }} \
            -t ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:latest \
            $( [ -n "$SEMVER" ] && echo "-t ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:$SEMVER" ) \
            -f Dockerfile.${{ matrix.service }} .
      
      - name: Scan Docker image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:latest
          format: 'sarif'
          output: 'trivy-${{ matrix.service }}-results.sarif'
      
      - name: Upload Trivy image scan results
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-${{ matrix.service }}-results.sarif'
      
      - name: Push Docker images to ACR
        run: |
          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:${{ steps.version.outputs.version }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:${{ steps.version.outputs.short_sha }}
          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.service }}:latest

  # Stage 4: Deploy to AKS
  deploy-to-aks:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-docker-images
    if: github.ref == 'refs/heads/master' || github.event.inputs.deploy == 'true'
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}
      url: http://57.156.24.83:8080
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER }}
      
      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy to AKS
        run: |
          kubectl apply -f k8s-6-services.yaml
      
      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/api-gateway -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/order-service -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/payment-service -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/shipping-service -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/product-service -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl rollout status deployment/user-service -n ${{ env.NAMESPACE }} --timeout=5m
      
      - name: Get deployment status
        run: |
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get svc -n ${{ env.NAMESPACE }}
      
      - name: Run smoke tests
        run: |
          API_GATEWAY_IP=$(kubectl get svc api-gateway -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "API Gateway IP: $API_GATEWAY_IP"
          
          # Wait for LoadBalancer IP
          for i in {1..30}; do
            if [ ! -z "$API_GATEWAY_IP" ]; then
              break
            fi
            echo "Waiting for LoadBalancer IP..."
            sleep 10
            API_GATEWAY_IP=$(kubectl get svc api-gateway -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          done
          
          # Simple health check
          curl -f http://$API_GATEWAY_IP:8080/actuator/health || echo "Health check failed"

  # Stage 4b: Deploy Production (requires environment approval)
  deploy-to-prod:
    name: Deploy to AKS (Production)
    runs-on: ubuntu-latest
    needs: build-docker-images
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      - name: Set AKS context
        uses: azure/aks-set-context@v4
        with:
          resource-group: ${{ env.AKS_RESOURCE_GROUP }}
          cluster-name: ${{ env.AKS_CLUSTER }}
      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      - name: Deploy manifests
        run: |
          kubectl apply -f k8s-6-services.yaml
      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/api-gateway -n ${{ env.NAMESPACE }} --timeout=5m || true
      - name: Smoke test production
        run: |
          API_GATEWAY_IP=$(kubectl get svc api-gateway -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "API Gateway IP: $API_GATEWAY_IP"
          curl -f http://$API_GATEWAY_IP:8080/actuator/health || echo "Health check failed"

  # Stage 5: Notification
  # Test commit
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [build-and-test, semantic-version, security-scan, build-docker-images, deploy-to-aks, deploy-to-prod]
    if: always()
    env:
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    
    steps:
      - name: Check job status
        id: check
        run: |
          if [ "${{ needs.build-and-test.result }}" == "failure" ] || \
             [ "${{ needs.security-scan.result }}" == "failure" ] || \
             [ "${{ needs.build-docker-images.result }}" == "failure" ] || \
             [ "${{ needs.deploy-to-aks.result }}" == "failure" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi
      
      - name: Send status notification
        run: |
          echo "Pipeline Status: ${{ steps.check.outputs.status }}"
          echo "Build: ${{ needs.build-and-test.result }}"
          echo "Security: ${{ needs.security-scan.result }}"
          echo "Docker: ${{ needs.build-docker-images.result }}"
          echo "Deploy Dev/Stage: ${{ needs.deploy-to-aks.result }}"
          echo "Deploy Prod: ${{ needs.deploy-to-prod.result }}"
      - name: Slack Notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK_URL: ${{ env.SLACK_WEBHOOK_URL }}
          SLACK_COLOR: ${{ steps.check.outputs.status == 'failure' && '#ff0000' || '#36a64f' }}
          SLACK_MESSAGE: |
            CI/CD ${{ steps.check.outputs.status == 'failure' && 'FAILED' || 'SUCCESS' }}
            Version: ${{ needs.semantic-version.outputs.version }}
            Repo: ${{ github.repository }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}
            Run ID: ${{ github.run_id }}
            Build: ${{ needs.build-and-test.result }}
            Security: ${{ needs.security-scan.result }}
            Docker: ${{ needs.build-docker-images.result }}
            Dev/Stage Deploy: ${{ needs.deploy-to-aks.result }}
            Prod Deploy: ${{ needs.deploy-to-prod.result }}
      - name: Create Issue on Failure
        if: steps.check.outputs.status == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `CI/CD Failure Run ${process.env.GITHUB_RUN_ID}`;
            const body = `Workflow: ${process.env.GITHUB_WORKFLOW}\nRun URL: ${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body
            });
